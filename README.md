<h1 align="center" style="color: crimson; font-size: 48px;">
  LABYRINTH
</h1>
<h2 align="center" style="color: LightYellow; font-size: 40px;">
  Cодержание
</h2>

1. Постановка задачи
- Входные параметры
- Формат результата
2. Выполнение
<h2 align="center" style="color: LightYellow; font-size: 38px;">
  Постановка задачи
</h2>
<div style="text-align: justify;">
Хотел описать всё условие, но воздержался, мало ли, все же это тест, который будет в публичном репо, поэтому здесь будет мем.
<img src="./content/Enakin.png" width="250">

<h3 align="center" style="color: LightYellow; font-size: 34px;">
  Входные параметры
</h3>

1. Размер лабиринта(два числа разделенных пробелом, означающих длину и ширину лабиринта).
2. Структура лабиринта (список строк с числами от 0 до 9; числа отделяются пробелами; строки - как в обычном тексте отделяются переносами строк).
3. Две координаты клеток лабиринта - старт и финиш, где каждая координата состоит из двух чисел - индекс строки и индекс столбца, разделенных пробелами.

Пример входных параметров:
```
3 3
1 2 0
2 0 1
9 1 0
0 0 2 1
```
<h3 align="center" style="color: LightYellow; font-size: 34px;">
  Формат результата
</h3>
Формат результата - также текстовый, состоящий из списка координат клеток, через которые программа "проложила" кратчайший путь, а список координат разделён переносом строки; в конце списка выводится точка(в отдельной строке).

Пример результата:
```
0 0
1 0
2 0
2 1
.
```
Первая строка - старт, последняя строка с числами - финиш.

Формат ошибки свободный, с кратким описанием конкретной проблемы(во входных параметрах или в работе программы). Чтобы понять, что при работе программы произошла ошибка, нужно вернуть любой код ошибки.

<h2 align="center" style="color: LightYellow; font-size: 38px;">
  Выполнение
</h2>
Основной идей было решение с помощью графа. Представить весь лабиринт в виде графа, где вершиной является клетка, а ребром будут соединения клеток, между которыми есть  проход.

Поиск самого пути, можно было бы использовать BFS, но это было бы слишком долго на больших данных. Поэтому был выбрал самый оптимальный поиск пути из одной координаты в другую - Алгоритм Дейкстры. Но алгоритм все равно имеет непростительную алгоритмическую сложность О(n^2), поэтому для поиска наименьшего пути в определенной клетки (то есть выбор следующего прыжка) будем использовать кучу, что существенно сократит время выполнения, а потому алгоритмическая сложность сократится до О(n*log(n)). По памяти в О(n) даже не смотря на то, что мы будем хранить оптимальный путь для каждой клеточки. Где n - количество всех клеточек в лабиринте.

Так как в условии не было сказано, что данный путь всегда имеется было решено выводить в качестве результата при отсутствии ответа (-1).
</div>
